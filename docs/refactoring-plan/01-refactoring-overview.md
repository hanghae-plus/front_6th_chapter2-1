# 🔧 리팩토링 개요 및 목표

## 📋 프로젝트 개요

### 대상 파일

- `src/basic/main.basic.js` (903줄)
- `src/main.original.js` (참고용)

### 리팩토링 목적

현재 코드의 더티코드 패턴을 제거하고 클린코드 원칙을 적용하여 가독성, 유지보수성, 확장성을 크게 향상시키는 것

## 🎯 리팩토링 목표

### 1. 가독성 향상

- **현재**: 15/100 (매우 낮음)
- **목표**: 80/100 (높음)
- **개선 방안**:
  - 의미 있는 변수명과 함수명 사용
  - 복잡한 로직을 작은 함수로 분리
  - 일관된 코딩 스타일 적용

### 2. 유지보수성 개선

- **현재**: 10/100 (매우 낮음)
- **목표**: 85/100 (높음)
- **개선 방안**:
  - 전역 변수 제거 및 모듈 패턴 적용
  - 단일 책임 원칙 준수
  - 중복 코드 제거

### 3. 코드량 최적화

- **현재**: 903줄
- **목표**: 약 500줄 (45% 감소)
- **개선 방안**:
  - 중복 코드 통합
  - 불필요한 코드 제거
  - 함수 분할로 재사용성 향상

### 4. 함수 구조 개선

- **현재**: 8개 함수 (거대한 함수 포함)
- **목표**: 약 25개 함수 (적절한 크기)
- **개선 방안**:
  - 288줄 함수를 10개 이하 함수로 분할
  - 단일 책임 원칙 적용

## 📊 현재 코드 문제점 분석

### 🔴 Critical Issues (즉시 해결 필요)

#### 1. 전역 변수 오염

```javascript
// 현재 상태: 10개 이상의 전역 변수
var prodList, sel, addBtn, cartDisp, sum, stockInfo;
var lastSel,
  bonusPts = 0,
  totalAmt = 0,
  itemCnt = 0;
```

**문제점**:

- 전역 스코프 오염
- 상태 추적 불가능
- 동시성 문제 발생 가능

#### 2. 거대한 함수

```javascript
// 현재 상태: 288줄의 거대한 함수
function handleCalculateCartStuff() {
  // 8가지 책임을 한 함수에서 처리
  // 1. 총액 계산
  // 2. 할인 적용
  // 3. 포인트 계산
  // 4. UI 업데이트
  // 5. 재고 체크
  // 6. 통계 수집
  // 7. DOM 스타일 변경
  // 8. 로깅
}
```

**문제점**:

- 단일 책임 원칙 위반
- 테스트하기 어려움
- 디버깅 어려움

#### 3. 중복 코드

```javascript
// 포인트 계산이 5곳에서 중복
// 패턴 1
pts = Math.floor(totalAmt / 1000);
if (new Date().getDay() === 2) pts *= 2;

// 패턴 2
basePoints = Math.floor(totalAmt / 1000);
if (new Date().getDay() === 2) finalPoints *= 2;
```

**문제점**:

- 버그 수정 시 모든 곳을 찾아 수정해야 함
- 일관성 없는 구현
- 유지보수 어려움

### 🟡 High Priority Issues

#### 1. 매직 넘버

```javascript
// 현재: 의미 불명한 숫자들
if (quantity < 10) return 0; // 10의 의미?
if (itemCnt >= 30) {
} // 30의 의미?
if (product.q < 5) {
} // 5의 의미?
```

#### 2. 일관성 없는 코딩 스타일

```javascript
// var, let, const 혼용
var prodList, sel, addBtn;
const PRODUCT_ONE = 'p1';
let p4 = 'p4';

// 다양한 반복문 패턴
for (var i = 0; i < length; i++) {}
prodList.forEach(p => {});
while (idx < nodes.length) {}
```

#### 3. 에러 처리 부재

```javascript
// null 체크 누락
var totalDiv = sum.querySelector('.text-2xl');
totalDiv.textContent = '₩' + Math.round(totalAmt); // totalDiv가 null이면?
```

## 🎯 리팩토링 후 기대 효과

### 1. 개발 생산성 향상

- **코드 이해 시간**: 30분 → 5분 (83% 단축)
- **버그 수정 시간**: 2시간 → 20분 (83% 단축)
- **새 기능 추가 시간**: 4시간 → 1시간 (75% 단축)

### 2. 코드 품질 향상

- **테스트 커버리지**: 0% → 80% 이상
- **코드 복잡도**: 매우 높음 → 낮음
- **순환 복잡도**: 15 → 3 이하

### 3. 팀 협업 개선

- **코드 리뷰 시간**: 1시간 → 15분
- **인수인계 시간**: 2일 → 2시간
- **신규 개발자 적응 시간**: 1주 → 1일

### 4. 유지보수 비용 절감

- **연간 유지보수 시간**: 200시간 → 50시간 (75% 절감)
- **버그 발생 빈도**: 월 5회 → 월 1회 (80% 감소)
- **기능 추가 비용**: 100% → 30% (70% 절감)

## 📈 성공 지표 (KPI)

### 정량적 지표

- [ ] 코드 라인 수: 903줄 → 500줄 이하
- [ ] 함수 개수: 8개 → 25개
- [ ] 전역 변수: 10개 → 0개
- [ ] 중복 코드: 90% 이상 제거
- [ ] 매직 넘버: 100% 상수화

### 정성적 지표

- [ ] 코드 가독성: 15/100 → 80/100
- [ ] 유지보수성: 10/100 → 85/100
- [ ] 테스트 가능성: 5/100 → 90/100
- [ ] 확장성: 10/100 → 80/100

## 🚀 다음 단계

1. **02-current-code-analysis.md** - 현재 코드 상세 분석
2. **03-refactoring-strategy.md** - 리팩토링 전략 수립
3. **04-module-pattern-design.md** - 모듈 패턴 설계
4. **05-function-decomposition.md** - 함수 분해 계획

## 📝 참고 자료

- [클린코드 원칙](../04-practical-clean-code-guide.md)
- [더티코드 분석](../02-dirty-code-analysis.md)
- [요구사항 명세](../01-PRD.md)
