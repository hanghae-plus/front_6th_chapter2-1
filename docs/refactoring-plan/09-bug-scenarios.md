# 🐛 버그 시나리오 분석

## 📋 개요

본 문서는 현재 코드의 각 문제점이 야기할 수 있는 구체적인 버그 시나리오를 분석하여, 리팩토링의 필요성을 명확히 하고 예방 방안을 제시합니다.

## 🔴 Critical Level 버그 시나리오

### 1. 전역 변수 오염으로 인한 버그

#### 시나리오 1: 동시성 문제

```javascript
// 현재 코드
var totalAmt = 0;
var itemCnt = 0;

function handleCalculateCartStuff() {
  totalAmt = 0; // 전역 변수 직접 수정
  itemCnt = 0;
  // ... 계산 로직
}

// 버그 시나리오
// 1. 사용자가 장바구니에 상품 추가
// 2. 동시에 다른 사용자가 같은 페이지에서 상품 추가
// 3. 두 사용자의 계산이 서로 간섭하여 잘못된 결과 발생
```

**예상 결과**:

- 사용자 A의 장바구니에 사용자 B의 상품이 나타남
- 총액 계산이 부정확해짐
- 포인트 계산 오류

#### 시나리오 2: 상태 불일치

```javascript
// 현재 코드
qtyElem.textContent = newQty;
itemToAdd['q']--; // DOM과 데이터 상태 불일치

// 버그 시나리오
// 1. 사용자가 수량 변경 중 네트워크 오류 발생
// 2. DOM은 업데이트되었지만 데이터는 업데이트되지 않음
// 3. 페이지 새로고침 시 잘못된 상태로 복원
```

**예상 결과**:

- 화면에는 5개로 표시되지만 실제 재고는 3개
- 결제 시 재고 부족 오류 발생

### 2. 거대한 함수로 인한 버그

#### 시나리오 3: 계산 오류

```javascript
// 현재 코드: 288줄의 handleCalculateCartStuff 함수
function handleCalculateCartStuff() {
  // 1. 초기화
  // 2. 재고 체크
  // 3. 가격 계산
  // 4. 할인 적용
  // 5. 포인트 계산
  // 6. UI 업데이트
  // 7. 통계 수집
  // 8. 로깅
}

// 버그 시나리오
// 1. 할인 계산 로직에서 오류 발생
// 2. 288줄 중 어느 부분에서 문제가 발생했는지 파악 어려움
// 3. 디버깅 시 전체 함수를 단계별로 추적해야 함
// 4. 수정 시 다른 부분에 영향 줄 가능성 높음
```

**예상 결과**:

- 할인 계산 오류로 잘못된 가격 표시
- 포인트 계산 오류
- UI 업데이트 실패

#### 시나리오 4: 메모리 누수

```javascript
// 현재 코드
function handleCalculateCartStuff() {
  // 288줄의 복잡한 로직
  // 중간에 예외 발생 시 리소스 정리 안됨
}

// 버그 시나리오
// 1. 함수 실행 중 예외 발생
// 2. 288줄 중간에서 함수가 중단됨
// 3. 할당된 리소스가 정리되지 않음
// 4. 반복 실행 시 메모리 누수 발생
```

**예상 결과**:

- 브라우저 메모리 사용량 지속적 증가
- 페이지 성능 저하
- 브라우저 크래시

### 3. 중복 코드로 인한 버그

#### 시나리오 5: 일관성 없는 계산

```javascript
// 현재 코드: 5곳에서 다른 방식으로 포인트 계산
// 패턴 1
pts = Math.floor(totalAmt / 1000);
if (new Date().getDay() === 2) pts *= 2;

// 패턴 2
basePoints = Math.floor(totalAmt / 1000);
if (new Date().getDay() === 2) finalPoints *= 2;

// 버그 시나리오
// 1. 개발자가 패턴 1의 로직을 수정
// 2. 패턴 2~5는 수정하지 않음
// 3. 같은 기능이 다른 결과를 반환
```

**예상 결과**:

- 장바구니에서는 100포인트, 결제 페이지에서는 80포인트
- 사용자 혼란 및 불만
- 비즈니스 로직 오류

#### 시나리오 6: 수정 누락

```javascript
// 현재 코드: 3곳에서 재고 체크
// 패턴 1
prodList.forEach(p => (totalStock += p.q));

// 패턴 2
for (var idx = 0; idx < prodList.length; idx++) {
  if (prodList[idx].q < 5 && prodList[idx].q > 0) {
    lowStockItems.push(prodList[idx].name);
  }
}

// 버그 시나리오
// 1. 재고 체크 로직 변경 필요
// 2. 패턴 1만 수정하고 패턴 2, 3은 수정하지 않음
// 3. 일부 기능에서만 새로운 로직 적용
```

**예상 결과**:

- 상품 선택에서는 재고 있음으로 표시
- 장바구니에서는 재고 부족으로 표시
- 사용자 혼란

## 🟡 High Level 버그 시나리오

### 4. 매직 넘버로 인한 버그

#### 시나리오 7: 비즈니스 규칙 변경 시 오류

```javascript
// 현재 코드
if (quantity < 10) return 0; // 10의 의미?
if (itemCnt >= 30) {
} // 30의 의미?
if (product.q < 5) {
} // 5의 의미?

// 버그 시나리오
// 1. 비즈니스 요구사항 변경: 할인 기준을 10개 → 5개로 변경
// 2. 개발자가 일부만 수정하고 나머지는 놓침
// 3. 코드 전체에서 10이라는 숫자를 찾아 수정해야 함
```

**예상 결과**:

- 일부 상품은 5개부터 할인, 일부는 10개부터 할인
- 비즈니스 규칙 불일치
- 고객 불만

#### 시나리오 8: 할인율 계산 오류

```javascript
// 현재 코드
if (curItem.id === PRODUCT_ONE) {
  disc = 10 / 100; // 10%
} else if (curItem.id === p2) {
  disc = 15 / 100; // 15%
}

// 버그 시나리오
// 1. 할인율 변경: 키보드 10% → 12%로 변경
// 2. 개발자가 10을 12로 수정
// 3. 10 / 100을 12 / 100으로 변경해야 하는데 12 / 100으로 수정
// 4. 실제로는 12%가 아닌 0.12% 할인 적용
```

**예상 결과**:

- 할인율이 예상과 다르게 적용
- 매출 손실 또는 과도한 할인

### 5. 일관성 없는 코딩 스타일로 인한 버그

#### 시나리오 9: 변수명 혼동

```javascript
// 현재 코드
var prodList, sel, addBtn;
const PRODUCT_ONE = 'p1';
let p4 = 'p4';

// 버그 시나리오
// 1. 새로운 개발자가 코드를 수정
// 2. prodList와 PRODUCT_ONE의 차이를 모름
// 3. 잘못된 변수를 수정하여 예상치 못한 동작 발생
```

**예상 결과**:

- 상품 목록이 업데이트되지 않음
- 잘못된 상품이 선택됨
- 기능 동작 오류

#### 시나리오 10: 반복문 패턴 혼동

```javascript
// 현재 코드
// 패턴 1
for (var i = 0; i < prodList.length; i++) {}

// 패턴 2
prodList.forEach(p => {});

// 패턴 3
while (idx < nodes.length) {}

// 버그 시나리오
// 1. 개발자가 새로운 반복문 추가
// 2. 기존 패턴을 혼동하여 잘못된 패턴 사용
// 3. 예상치 못한 동작 발생
```

**예상 결과**:

- 무한 루프 발생
- 배열 인덱스 오류
- 성능 저하

## 🟢 Medium Level 버그 시나리오

### 6. 에러 처리 부재로 인한 버그

#### 시나리오 11: DOM 요소 null 오류

```javascript
// 현재 코드
var totalDiv = sum.querySelector('.text-2xl');
totalDiv.textContent = '₩' + Math.round(totalAmt);

// 버그 시나리오
// 1. DOM 구조 변경으로 .text-2xl 요소가 제거됨
// 2. querySelector가 null을 반환
// 3. null.textContent 접근으로 TypeError 발생
```

**예상 결과**:

- JavaScript 오류로 페이지 동작 중단
- 사용자 경험 저하

#### 시나리오 12: 배열 경계 오류

```javascript
// 현재 코드
var luckyIdx = Math.floor(Math.random() * prodList.length);
var luckyItem = prodList[luckyIdx];

// 버그 시나리오
// 1. prodList가 비어있는 상태에서 실행
// 2. luckyIdx가 0이 되어 prodList[0] 접근
// 3. undefined 접근으로 오류 발생
```

**예상 결과**:

- 상품이 없을 때 오류 발생
- 페이지 크래시

### 7. 성능 문제로 인한 버그

#### 시나리오 13: 메모리 누수

```javascript
// 현재 코드
window.analyticsData.push(cartAnalytics); // 무한정 증가

// 버그 시나리오
// 1. 사용자가 장바구니를 반복적으로 조작
// 2. analyticsData 배열이 계속 증가
// 3. 메모리 사용량 지속적 증가
```

**예상 결과**:

- 브라우저 메모리 부족
- 페이지 성능 저하
- 브라우저 크래시

#### 시나리오 14: 불필요한 재계산

```javascript
// 현재 코드
if (new Date().getDay() === 2) {
}
if (new Date().getDay() === 2) {
}

// 버그 시나리오
// 1. 화요일 할인 계산이 여러 번 실행됨
// 2. 매번 새로운 Date 객체 생성
// 3. 성능 저하 및 일관성 문제
```

**예상 결과**:

- 페이지 응답 속도 저하
- CPU 사용량 증가
- 배터리 소모 증가 (모바일)

## 🛡️ 버그 예방 방안

### 1. 전역 변수 제거

- **모듈 패턴 적용**: 상태를 캡슐화하여 외부 간섭 방지
- **상태 관리 중앙화**: 모든 상태 변경을 통제된 방법으로만 수행

### 2. 함수 분할

- **단일 책임 원칙**: 각 함수가 하나의 명확한 책임만 가지도록
- **테스트 가능한 구조**: 각 함수를 독립적으로 테스트 가능하도록

### 3. 중복 코드 제거

- **DRY 원칙**: 공통 로직을 함수로 추출
- **일관성 보장**: 모든 곳에서 동일한 로직 사용

### 4. 매직 넘버 상수화

- **명명된 상수**: 의미를 명확히 하는 상수 정의
- **중앙 관리**: 모든 상수를 한 곳에서 관리

### 5. 일관된 코딩 스타일

- **코딩 컨벤션**: 팀 전체가 동일한 스타일 사용
- **자동화 도구**: ESLint, Prettier 등으로 일관성 강제

### 6. 에러 처리 강화

- **방어적 프로그래밍**: 모든 예외 상황 고려
- **명시적 에러 처리**: null 체크, 경계 체크 등

### 7. 성능 최적화

- **메모리 관리**: 불필요한 객체 생성 방지
- **캐싱 전략**: 반복 계산 결과 캐싱

## 📊 버그 시나리오 통계

### 심각도별 분류

- **Critical**: 4개 시나리오 (동시성, 상태 불일치, 계산 오류, 메모리 누수)
- **High**: 6개 시나리오 (일관성, 비즈니스 규칙, 변수명, 반복문)
- **Medium**: 4개 시나리오 (DOM 오류, 배열 오류, 성능 문제)

### 예상 영향도

- **사용자 경험**: 8개 시나리오
- **비즈니스 로직**: 6개 시나리오
- **시스템 안정성**: 4개 시나리오

## 🎯 결론

이러한 버그 시나리오들은 현재 코드의 문제점이 실제로 어떤 위험을 초래할 수 있는지를 보여줍니다. 리팩토링을 통해 이러한 잠재적 버그들을 사전에 방지하고, 안정적이고 유지보수 가능한 코드로 개선할 수 있습니다.
