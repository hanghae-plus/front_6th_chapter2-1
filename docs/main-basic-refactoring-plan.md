# main.basic.js 리팩토링 계획

## 📋 개요

`main.basic.js` 파일의 코드 품질을 개선하고 유지보수성을 향상시키기 위한 단계별 리팩토링 계획입니다.

## 🎯 목표

- 전역 변수 제거 및 중앙 집중식 상태 관리
- 함수 분리 및 단일 책임 원칙 적용
- 중복 코드 제거 및 재사용성 향상
- DOM 조작 로직 분리
- 에러 처리 개선
- 성능 최적화

## 🚨 우선순위별 리팩토링 계획

### **🔥 P0 - 긴급 (Critical Issues)**

#### **1. 전역 변수 제거 및 상태 관리 개선**

- **문제점**:
  - `itemCounts`, `lastSelect`, `totalAmount` 등이 전역 변수로 관리됨
  - DOM 요소들(`stockInfo`, `select`, `addButton`, `cartDisplay`)이 전역 변수로 관리됨
  - 상태 변경 시 일관성 보장이 어려움

- **해결 방안**:
  - Store 패턴을 사용한 중앙 집중식 상태 관리 구현
  - 상태 변경 시 자동으로 UI 업데이트되도록 구독 패턴 적용
  - DOM 요소 참조를 Store 내부에서 관리

- **예상 시간**: 4-6시간
- **산출물**: `Store.js`, 상태 관리 시스템

#### **2. 함수 분리 및 단일 책임 원칙 적용**

- **문제점**:
  - `handleCalculateCartStuff()` 함수가 200+ 라인으로 너무 복잡함
  - 계산, 렌더링, 이벤트 처리가 한 함수에 섞여있음
  - 테스트하기 어렵고 수정 시 부작용 위험

- **해결 방안**:
  - 계산 로직과 렌더링 로직 분리
  - 각 함수가 단일 책임을 가지도록 리팩토링
  - 순수 함수로 만들어 테스트 가능하게 개선

- **예상 시간**: 6-8시간
- **산출물**: 분리된 계산 함수들, 렌더링 함수들

### **⚡ P1 - 높음 (High Priority)**

#### **3. 중복 코드 제거**

- **문제점**:

  ```javascript
  // 반복되는 패턴
  for (let j = 0; j < PRODUCT_LIST.length; j++) {
    if (PRODUCT_LIST[j].id === selItem) {
      curItem = PRODUCT_LIST[j];
      break;
    }
  }
  ```

  - 상품 검색 로직이 여러 곳에서 반복됨
  - 코드 중복으로 인한 유지보수성 저하

- **해결 방안**:
  - `findProductById()` 유틸리티 함수 생성
  - `findProductsByCondition()` 등 범용 검색 함수 구현
  - Map을 사용한 O(1) 검색 성능 개선

- **예상 시간**: 2-3시간
- **산출물**: `utils/productUtils.js`

#### **4. 매직 넘버 및 하드코딩 제거**

- **문제점**:

  ```javascript
  disc = DISCOUNT_RATE_PRODUCT_1 / 100; // 하드코딩
  ```

  - 할인율 계산에서 하드코딩된 값들
  - 상품별 할인율이 switch문으로 관리됨

- **해결 방안**:
  - 상품별 할인율 매핑 객체 생성
  - 설정 기반 할인율 관리 시스템 구현
  - 상수 파일에서 중앙 집중식 관리

- **예상 시간**: 2-3시간
- **산출물**: `config/discountConfig.js`

#### **5. DOM 조작 로직 분리**

- **문제점**:
  - HTML 문자열이 JavaScript에 하드코딩됨
  - DOM 생성 로직이 이벤트 핸들러에 섞여있음
  - 템플릿과 로직이 분리되지 않음

- **해결 방안**:
  - 템플릿 함수로 HTML 생성 로직 분리
  - 컴포넌트 기반 DOM 생성 시스템 구현
  - 템플릿과 데이터 바인딩 분리

- **예상 시간**: 3-4시간
- **산출물**: `templates/cartItemTemplate.js`, `templates/productOptionTemplate.js`

### **🔄 P2 - 중간 (Medium Priority)**

#### **6. 이벤트 핸들러 정리**

- **문제점**:
  - 인라인 이벤트 리스너와 긴 함수들
  - 이벤트 위임 패턴 미사용
  - 이벤트 핸들러 간 의존성 복잡

- **해결 방안**:
  - 이벤트 위임 패턴 적용
  - 이벤트 핸들러를 작은 함수들로 분리
  - 이벤트 버스 패턴으로 컴포넌트 간 통신 개선

- **예상 시간**: 3-4시간
- **산출물**: `events/eventHandlers.js`, `events/eventBus.js`

#### **7. 계산 로직 모듈화**

- **문제점**:
  - 할인, 포인트, 재고 계산이 한 함수에 섞여있음
  - 계산 로직이 비즈니스 로직과 UI 로직에 섞여있음
  - 계산 결과 재사용이 어려움

- **해결 방안**:
  - `DiscountCalculator` 클래스 생성
  - `PointCalculator` 클래스 생성
  - `StockManager` 클래스 생성
  - 계산 결과 캐싱 시스템 구현

- **예상 시간**: 4-5시간
- **산출물**: `calculators/DiscountCalculator.js`, `calculators/PointCalculator.js`, `managers/StockManager.js`

#### **8. 에러 처리 개선**

- **문제점**:
  - `alert()` 사용으로 사용자 경험 저하
  - 부족한 에러 처리와 예외 상황 대응
  - 에러 발생 시 앱 상태 불일치 가능성

- **해결 방안**:
  - 구조화된 에러 처리 시스템 구현
  - 사용자 친화적인 에러 메시지 표시
  - 에러 발생 시 앱 상태 복구 메커니즘 구현

- **예상 시간**: 2-3시간
- **산출물**: `utils/errorHandler.js`, `components/ErrorDisplay.js`

### **📈 P3 - 낮음 (Low Priority)**

#### **9. 성능 최적화**

- **문제점**:
  - 불필요한 DOM 조작과 계산
  - 이벤트 핸들러에서 과도한 함수 호출
  - 메모리 누수 가능성

- **해결 방안**:
  - 디바운싱을 통한 이벤트 최적화
  - 메모이제이션을 통한 계산 최적화
  - 가상 스크롤링 적용 (필요시)

- **예상 시간**: 3-4시간
- **산출물**: `utils/performance.js`, `utils/memoization.js`

#### **10. 타입 안정성 개선**

- **문제점**:
  - 타입 체크 부족
  - 런타임 에러 발생 가능성
  - 코드 가독성 저하

- **해결 방안**:
  - JSDoc 주석 추가
  - 런타임 타입 검증 함수 구현
  - 타입 가드 함수 생성

- **예상 시간**: 2-3시간
- **산출물**: `utils/typeGuards.js`, JSDoc 주석 추가

## 🗓️ 단계별 실행 계획

### **Phase 1 (1-2일): 긴급 문제 해결**

1. **Store 패턴 구현으로 전역 변수 제거**
   - 상태 관리 시스템 설계
   - Store 클래스 구현
   - 기존 전역 변수들을 Store로 마이그레이션

2. **`handleCalculateCartStuff()` 함수 분리**
   - 계산 로직과 렌더링 로직 분리
   - 각 함수의 단일 책임 명확화
   - 함수 간 의존성 최소화

3. **중복 코드 제거를 위한 유틸리티 함수 생성**
   - `findProductById()` 함수 구현
   - 공통 로직 추출
   - 성능 최적화 (Map 사용)

### **Phase 2 (3-4일): 핵심 리팩토링**

1. **DOM 조작 로직 분리**
   - 템플릿 함수 생성
   - 컴포넌트 기반 DOM 생성
   - 데이터 바인딩 시스템 구현

2. **계산 로직 모듈화**
   - `DiscountCalculator` 클래스 구현
   - `PointCalculator` 클래스 구현
   - `StockManager` 클래스 구현

3. **이벤트 핸들러 정리**
   - 이벤트 위임 패턴 적용
   - 이벤트 핸들러 분리
   - 이벤트 버스 패턴 구현

### **Phase 3 (5-6일): 품질 개선**

1. **에러 처리 개선**
   - 구조화된 에러 처리 시스템 구현
   - 사용자 친화적인 에러 메시지
   - 에러 복구 메커니즘

2. **성능 최적화**
   - 디바운싱 적용
   - 메모이제이션 구현
   - 불필요한 계산 제거

3. **타입 안정성 개선**
   - JSDoc 주석 추가
   - 런타임 타입 검증
   - 타입 가드 함수 구현

### **Phase 4 (7일): 테스트 및 검증**

1. **모든 테스트 통과 확인**
   - 기존 테스트 케이스 검증
   - 새로운 테스트 케이스 작성
   - 테스트 커버리지 확인

2. **기능 검증**
   - 모든 기능이 정상 작동하는지 확인
   - 성능 테스트 수행
   - 사용자 시나리오 테스트

3. **코드 리뷰 및 최종 정리**
   - 코드 품질 검토
   - 문서화 완료
   - 최종 정리 및 커밋

## 📊 예상 소요 시간

| 우선순위 | 작업               | 예상 시간 | 누적 시간 |
| -------- | ------------------ | --------- | --------- |
| P0       | 전역 변수 제거     | 4-6시간   | 4-6시간   |
| P0       | 함수 분리          | 6-8시간   | 10-14시간 |
| P1       | 중복 코드 제거     | 2-3시간   | 12-17시간 |
| P1       | 매직 넘버 제거     | 2-3시간   | 14-20시간 |
| P1       | DOM 조작 분리      | 3-4시간   | 17-24시간 |
| P2       | 이벤트 핸들러 정리 | 3-4시간   | 20-28시간 |
| P2       | 계산 로직 모듈화   | 4-5시간   | 24-33시간 |
| P2       | 에러 처리 개선     | 2-3시간   | 26-36시간 |
| P3       | 성능 최적화        | 3-4시간   | 29-40시간 |
| P3       | 타입 안정성 개선   | 2-3시간   | 31-43시간 |

**총 예상 시간: 31-43시간 (약 4-6일)**

## 🎯 성공 지표

### **코드 품질 지표**

- [ ] 전역 변수 0개
- [ ] 함수당 평균 라인 수 < 30줄
- [ ] 중복 코드 제거율 > 80%
- [ ] 테스트 커버리지 > 90%

### **성능 지표**

- [ ] 초기 로딩 시간 < 1초
- [ ] 이벤트 응답 시간 < 100ms
- [ ] 메모리 사용량 최적화

### **유지보수성 지표**

- [ ] 함수 단일 책임 원칙 준수
- [ ] 의존성 최소화
- [ ] 코드 가독성 향상

## 🚀 다음 단계

1. **Phase 1 시작**: Store 패턴 구현으로 전역 변수 제거
2. **코드 리뷰**: 각 Phase 완료 후 코드 리뷰 진행
3. **테스트**: 각 단계별 테스트 실행 및 검증
4. **문서화**: 리팩토링 과정과 결과 문서화

---

_이 계획은 코드 품질 개선을 위한 가이드라인이며, 실제 구현 과정에서 필요에 따라 조정될 수 있습니다._
